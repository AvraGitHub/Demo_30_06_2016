*&---------------------------------------------------------------------*
*& Report  ZDTP_MASSDOWNLOAD_AVRA
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  ZDTP_MASSDOWNLOAD_AVRA.

*----------------------------------------------------------------------------------------------------------------------
*  SAP Tables
*----------------------------------------------------------------------------------------------------------------------
tables: trdir, seoclass, tfdir, enlfdir, dd02l, tadiv.
type-pools: abap, seor.

*----------------------------------------------------------------------------------------------------------------------
*  Types
*----------------------------------------------------------------------------------------------------------------------
* text element structure
types: tTextTable like textpool.
* GUI titles
types: tGUITitle like d347t.

* Message classes
types: begin of tMessage,
         arbgb like t100-arbgb,
         stext like t100a-stext,
         msgnr like t100-msgnr,
         text  like t100-text,
       end of tMessage.

* Screen flow.
types: begin of tScreenFlow,
         screen like d020s-dnum,
         code like d022s-line,
       end of tScreenFlow.

* Holds a tabledefinition
types: begin of tDictTableStructure,
         fieldname like dd03l-fieldname,
         position  like dd03l-position,
         keyflag   like dd03l-keyflag,
         rollname  like dd03l-rollname,
         domname   like dd03l-domname,
         datatype  like dd03l-datatype,
         leng      like dd03l-leng,
         lowercase type lowercase,
         ddtext    like dd04t-ddtext,
       end of tdictTableStructure.

* Holds a tables attributes + its definition
types: begin of tDictTable,
         tablename    like dd03l-tabname,
         tableTitle   like dd02t-ddtext,
         iStructure type tDictTableStructure occurs 0,
       end of tDictTable.

types: begin of tDictFilename,
         tablename    like dd03l-tabname,
         filename type string,
       end of tDictFilename.

* Include program names
types: begin of tInclude,
         includeName like trdir-name,
         includeTitle like tftit-stext,
       end of tInclude.

* Exception class texts
types: begin of tConcept,
         constName type string,
         concept type sotr_conc,
       end of tConcept.

* Method
types: begin of tMethod,
         cmpName(61),
         descript like vseomethod-descript,
         exposure like vseomethod-exposure,
         methodKey type string,
       end of tMethod.

* Interfaces
types: begin of tInterface,
         interfaceName like vseoclass-clsname,
       end of tInterface.

* Class
types: begin of tClass,
         scanned(1),
         clsname like vseoclass-clsname,
         descript like vseoclass-descript,
         msg_id like vseoclass-msg_id,
         exposure like vseoclass-exposure,
         state like vseoclass-state,
         clsfinal like vseoclass-clsfinal,
         r3release like vseoclass-r3release,
         iMethods type tMethod occurs 0,
         iDictStruct type tDictTable occurs 0,
         iTextElements type tTextTable occurs 0,
         iMessages type tMessage occurs 0,
         iInterfaces type tInterface occurs 0,
         iConcepts type tConcept occurs 0,
         textElementKey type string,
         publicClassKey type string,
         privateClassKey type string,
         protectedClassKey type string,
         typesClassKey type string,
         exceptionClass type abap_bool,
       end of tClass.

* function modules
types: begin of tFunction,
         functionName like tfdir-funcName,
         functionGroup like enlfdir-area,
         includeNumber like tfdir-include,
         functionMainInclude like tfdir-funcName,
         functionTitle like tftit-stext,
         topIncludeName like tfdir-funcName,
         progname like tfdir-pname,
         programLinkName like tfdir-pname,
         messageClass like t100-arbgb,
         iTextElements type tTextTable occurs 0,
         iSelectiontexts type tTextTable occurs 0,
         iMessages type tMessage occurs 0,
         iIncludes type tInclude occurs 0,
         iDictStruct type tDictTable occurs 0,
         iGUITitle type tGUITitle occurs 0,
         iScreenFlow type tScreenFlow occurs 0,
       end of tFunction.

types: begin of tProgram,
         progname like trdir-name,
         programTitle like tftit-stext,
         subc like trdir-subc,
         messageClass like t100-arbgb,
         iMessages type tMessage occurs 0,
         iTextElements type tTextTable occurs 0,
         iSelectiontexts type tTextTable occurs 0,
         iGUITitle type tGUITitle occurs 0,
         iScreenFlow type tScreenFlow occurs 0,
         iIncludes type tInclude occurs 0,
         iDictStruct type tDictTable occurs 0,
       end of tProgram.

*----------------------------------------------------------------------------------------------------------------------
*  Internal tables
*----------------------------------------------------------------------------------------------------------------------
*  Dictionary object
data: iDictionary type standard table of tDictTable with header line.
*  Dictionary objects which have previously been downloaded
data: iDictFilename type standard table of tDictFilename with header line.
* Function modules.
data: iFunctions type standard table of tFunction with header line.
* Function modules used within programs.
data: iProgFunctions type standard table of tFunction with header line.
* Tree display structure.
data: iTreeDisplay type standard table of snodetext with header line.
* Message class data
data: iMessages type standard table of tMessage with header line.
* Holds a single message class an all of its messages
data: iSingleMessageClass type standard table of tMessage with header line.
* Holds program related data
data: iPrograms type standard table of tProgram with header line.
* Classes
data: iClasses type standard table of tClass with header line.
* Table of paths created on the SAP server
data: iServerPaths type standard table of string with header line.

*----------------------------------------------------------------------------------------------------------------------
*  Table prototypes
*----------------------------------------------------------------------------------------------------------------------
data: dumiDictStructure type standard table of tDictTableStructure.
data: dumiTextTab type standard table of tTextTable.
data: dumiIncludes type standard table of tInclude.
data: dumiHtml type standard table of string.
data: dumiHeader type standard table of string .
data: dumiScreen type standard table of tScreenFlow .
data: dumIGUITitle type standard table of tGUITitle.
data: dumiMethods type standard table of tMethod.
data: dumiConcepts type standard table of tConcept.
data: dumiInterfaces type standard table of tInterface.

*----------------------------------------------------------------------------------------------------------------------
*   Global objects
*----------------------------------------------------------------------------------------------------------------------
data: objFile type ref to cl_gui_frontend_services.
data: objRuntimeError type ref to cx_root.

*----------------------------------------------------------------------------------------------------------------------
*  Constants
*----------------------------------------------------------------------------------------------------------------------
constants: VERSIONNO type string value '1.4.4'.
constants: TABLES type string value 'TABLES'.
constants: TABLE type string value 'TABLE'.
constants: LIKE type string value 'LIKE'.
constants: TYPE type string value 'TYPE'.
constants: TYPEREFTO type string value 'TYPE REF TO'.
constants: STRUCTURE type string value 'STRUCTURE'.
constants: LOWSTRUCTURE type string value 'structure'.
constants: OCCURS type string value 'OCCURS'.
constants: FUNCTION type string value 'FUNCTION'.
constants: CALLFUNCTION type string value ' CALL FUNCTION'.
constants: MESSAGE type string  value 'MESSAGE'.
constants: INCLUDE type string value 'INCLUDE'.
constants: LOWINCLUDE type string value 'include'.
constants: DESTINATION type string value 'DESTINATION'.
constants: IS_TABLE type string value 'T'.
constants: IS_PROGRAM type string value 'P'.
constants: IS_SCREEN type string value 'S'.
constants: IS_GUITITLE type string value 'G'.
constants: IS_DOCUMENTATION type string value 'D'.
constants: IS_MESSAGECLASS type string value 'MC'.
constants: IS_FUNCTION type string value 'F'.
constants: IS_CLASS type string value 'C'.
constants: IS_METHOD type string value 'M'.
constants: ASTERIX type string value '*'.
constants: COMMA type string value ','.
constants: PERIOD type string value '.'.
constants: DASH type string value '-'.
constants: TRUE type abap_bool value 'X'.
constants: FALSE type abap_bool value ''.
constants: LT type string value '&lt;'.
constants: GT type string value '&gt;'.
constants: UNIX type string value 'UNIX'.
constants: NON_UNIX type string value 'not UNIX'.
constants: HTMLEXTENSION type string value 'html'.
constants: TEXTEXTENSION type string value 'txt'.
constants: SS_CODE type c value 'C'.
constants: SS_TABLE type c value 'T'.

*----------------------------------------------------------------------------------------------------------------------
*  Global variables
*----------------------------------------------------------------------------------------------------------------------
data: statusBarMessage(100).
data: forcedExit type abap_bool value FALSE.
data: startTime like sy-uzeit.
data: runTime like sy-uzeit.
data: downloadFileExtension type string.
data: downloadFolder type string.
data: serverSlashSeparator type string.
data: frontendSlashSeparator type string.
data: slashSeparatorToUse type string.
data: serverFilesystem type filesys_d.
data: serverFolder type string.
data: frontendOpSystem type string.
data: serverOpSystem type string.
data: customerNameSpace type string.
ranges: soProgramName for trdir-name.
ranges: soAuthor for usr02-bname.
ranges: soTableNames for dd02l-tabname.
ranges: soFunctionName  for tfdir-funcName.
ranges: soClassName for vseoclass-clsname.
ranges: soFunctionGroup for enlfdir-area.
field-symbols: <waDictStruct> type tDictTable.

*----------------------------------------------------------------------------------------------------------------------
*  Selection screen declaration
*----------------------------------------------------------------------------------------------------------------------
* Author
selection-screen: begin of block b1 with frame title tBlock1.
  selection-screen begin of line.
    selection-screen comment 5(23) tAuth.
    parameters: pAuth like usr02-bname memory id MAUTH.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 5(36) tPmod.
    parameters: pMod as checkbox.
  selection-screen end of line.
selection-screen: end of block b1.

selection-screen begin of block b2 with frame title tBlock2.
* Tables
  selection-screen begin of line.
    parameters: rTable radiobutton group r1.
    selection-screen comment 5(15) tRtable.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tPtable.
    select-options: soTable for dd02l-tabname.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(79) tTnote.
  selection-screen end of line.

* Message classes
  selection-screen begin of line.
    parameters: rMess radiobutton group r1.
    selection-screen comment 5(18) tPMes.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(18) tMname.
    parameters: pMname like t100-arbgb memory id MMNAME.
  selection-screen end of line.

* Function modules
  selection-screen begin of line.
    parameters: rFunc radiobutton group r1.
    selection-screen comment 5(30) tRfunc.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tPfname.
    select-options: soFname for tfdir-funcName.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tFgroup.
    select-options: soFgroup for enlfdir-area.
  selection-screen end of line.

* Classes
  selection-screen begin of line.
    parameters: rClass radiobutton group r1.
    selection-screen comment 5(30) tRClass.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tPcName.
    select-options: soClass for seoclass-clsname.
  selection-screen end of line.

* Programs / includes
  selection-screen begin of line.
    parameters: rProg radiobutton group r1 default 'X'.
    selection-screen comment 5(18) tProg.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 10(15) tRpname.
    select-options: soProg for trdir-name.
  selection-screen end of line.

  selection-screen skip.
* Language
  selection-screen begin of line.
    selection-screen comment 1(27) tMLang.
    parameters: pMLang like t100-sprsl default 'EN'.
  selection-screen end of line.

* Package
  selection-screen begin of line.
    selection-screen comment 1(24) tPack.
    select-options: soPack for tadiv-devclass.
  selection-screen end of line.


* Customer objects
  selection-screen begin of line.
    selection-screen comment 1(27) tCust.
    parameters: pCust as checkbox default 'X'.
  selection-screen end of line.

* Alt customer name range
  selection-screen begin of line.
    selection-screen comment 1(27) tNRange.
    parameters: pCName type namespace memory id MNAMESPACE.
  selection-screen end of line.
selection-screen: end of block b2.

* Additional things to download.
selection-screen: begin of block b3 with frame title tBlock3.
  selection-screen begin of line.
    selection-screen comment 1(33) tPtext.
    parameters: pText as checkbox default 'X' memory id MTEXT.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tMess.
    parameters: pMess as checkbox default 'X' memory id MMESS.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPinc.
    parameters: pInc as checkbox default 'X' memory id MINC.
    selection-screen comment 40(20) tReci.
    parameters: pReci as checkbox default 'X' memory id MRECI.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPfunc.
    parameters: pFunc as checkbox default 'X' memory id MFUNC.
    selection-screen comment 40(20) tRecf.
    parameters: pRecf as checkbox default 'X' memory id MRECF.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tRecC.
    parameters: pRecC as checkbox default 'X' memory id MRECC.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tFDoc.
    parameters: pFDoc as checkbox default 'X' memory id MFDOC.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tCDoc.
    parameters: pCDoc as checkbox default 'X' memory id MCDOC.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPscr.
    parameters: pScr as checkbox default 'X' memory id MSCR.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tPdict.
    parameters: pDict as checkbox default 'X' memory id MDICT.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(33) tSortT.
    parameters: pSortT as checkbox default ' ' memory id MSORTT.
  selection-screen end of line.
selection-screen: end of block b3.

* File details
selection-screen: begin of block b4 with frame title tBlock4.
  selection-screen begin of line.
    selection-screen comment 1(20) tPhtml.
    parameters: pHtml radiobutton group g1 default 'X'.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 5(29) tBack.
    parameters: pBack as checkbox default 'X'.
  selection-screen end of line.

  selection-screen begin of line.
    selection-screen comment 1(20) tPtxt.
    parameters: pTxt radiobutton group g1.
  selection-screen end of line.

  selection-screen skip.

* Download to SAP server
  selection-screen begin of line.
    selection-screen comment 1(25) tServ.
    parameters: pServ radiobutton group g2.
  selection-screen end of line.
  selection-screen begin of line.
    selection-screen comment 8(20) tSPath.
    parameters: pLogical like filename-fileintern memory id MLOGICAL.
  selection-screen end of line.
  selection-screen comment /28(60) tSDPath.

* Download to PC
  selection-screen begin of line.
    selection-screen comment 1(25) tPc.
    parameters: pPc radiobutton group g2 default 'X'.
  selection-screen end of line.
  selection-screen begin of line.
    selection-screen comment 8(20) tPpath.
    parameters: pFolder like rlgrap-filename memory id MFOLDER.
  selection-screen end of line.
selection-screen: end of block b4.

* Display options
selection-screen: begin of block b5 with frame title tBlock5.
* Display final report
  selection-screen begin of line.
    selection-screen comment 1(33) tRep.
    parameters: pRep as checkbox default 'X'.
  selection-screen end of line.
* Display progress messages
  selection-screen begin of line.
    selection-screen comment 1(33) tProMess.
    parameters: pProMess as checkbox default 'X'.
  selection-screen end of line.
selection-screen: end of block b5.

*----------------------------------------------------------------------------------------------------------------------
* Display a directory picker window
*----------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for pFolder.

data: objFile type ref to cl_gui_frontend_services.
data: pickedFolder type string.
data: initialFolder type string.

  if sy-batch is initial.
    create object objFile.

    if not pFolder is initial.
      initialFolder = pFolder.
    else.
      objFile->get_temp_directory( changing temp_dir = initialFolder
                                   exceptions cntl_error = 1
                                             error_no_gui = 2
                                             not_supported_by_gui = 3 ).
    endif.

    objFile->directory_browse( exporting initial_folder = initialFolder
                               changing selected_folder = pickedFolder
                               exceptions cntl_error = 1
                                          error_no_gui = 2
                                          not_supported_by_gui = 3 ).

    if sy-subrc = 0.
      pFolder = pickedFolder.
    else.
      write: / 'An error has occured picking a folder'.
    endif.
  endif.

*----------------------------------------------------------------------------------------------------------------------
at selection-screen.
*----------------------------------------------------------------------------------------------------------------------
  case 'X'.
    when pPc.
      if pFolder is initial.
*       User must enter a path to save to
        message e000(oo) with 'You must enter a file path'.
      endif.

    when pServ.
      if pLogical is initial.
*       User must enter a logical path to save to
        message e000(oo) with 'You must enter a logical file name'.
      endif.
  endcase.

*----------------------------------------------------------------------------------------------------------------------
at selection-screen on pLogical.
*----------------------------------------------------------------------------------------------------------------------
  if not pServ is initial.
    call function 'FILE_GET_NAME' exporting logical_filename = pLogical
                                  importing file_name = serverFolder
                                  exceptions file_not_found = 1
                                             others = 2.
    if sy-subrc = 0.
      if serverFolder is initial.
        message e000(oo) with 'No file path returned from logical filename'.
      else.
*       Path to display on the selection screen
        tSDPath = serverFolder.
*       Remove the trailing slash off the path as the subroutine buildFilename will add an extra one
        shift serverFolder right deleting trailing serverSlashSeparator.
        shift serverFolder left deleting leading space.
      endif.
    else.
      message e000(oo) with 'Logical filename does not exist'.
    endif.
  endif.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soProg-low.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  = 'PROG'
                                                      object_name  = soProg-low
                                                      suppress_selection   = 'X'
                                                      use_alv_grid = ''
                                                      without_personal_list = ''
                                            importing object_name_selected = soProg-low
                                            exceptions cancel = 1.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soProg-high.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  = 'PROG'
                                                      object_name  = soProg-high
                                                      suppress_selection   = 'X'
                                                      use_alv_grid = ''
                                                      without_personal_list = ''
                                            importing object_name_selected = soProg-high
                                            exceptions cancel = 1.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soClass-low.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'F4_DD_ALLTYPES' exporting object = soClass-low
                                           suppress_selection = 'X'
                                           display_only = ''
                                           only_types_for_clifs = 'X'
                                 importing result = soClass-low.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soClass-high.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'F4_DD_ALLTYPES' exporting object = soClass-high
                                           suppress_selection = 'X'
                                           display_only = ''
                                           only_types_for_clifs = 'X'
                                 importing result = soClass-high.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soFName-low.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  = 'FUNC'
                                                      object_name  = soFname-low
                                                      suppress_selection   = 'X'
                                                      use_alv_grid = ''
                                                      without_personal_list = ''
                                            importing object_name_selected = soFName-low
                                            exceptions cancel = 1.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soFName-high.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  = 'FUNC'
                                                      object_name  = soFname-high
                                                      suppress_selection   = 'X'
                                                      use_alv_grid = ''
                                                      without_personal_list = ''
                                            importing object_name_selected = soFName-high
                                            exceptions cancel = 1.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soFGroup-low.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  = 'FUGR'
                                                      object_name  = soFGroup-low
                                                      suppress_selection   = 'X'
                                                      use_alv_grid = ''
                                                      without_personal_list = ''
                                            importing object_name_selected = soFGroup-low
                                            exceptions cancel = 1.

* ---------------------------------------------------------------------------------------------------------------------
at selection-screen on value-request for soFGroup-high.
* ---------------------------------------------------------------------------------------------------------------------
  call function 'REPOSITORY_INFO_SYSTEM_F4' exporting object_type  = 'FUGR'
                                                      object_name  = soFGroup-high
                                                      suppress_selection   = 'X'
                                                      use_alv_grid = ''
                                                      without_personal_list = ''
                                            importing object_name_selected = soFGroup-high
                                            exceptions cancel = 1.

*----------------------------------------------------------------------------------------------------------------------
* initialisation
*----------------------------------------------------------------------------------------------------------------------
initialization.
* Parameter screen texts.
  tBlock1 = 'Author (Optional)'.
  tBlock2 = 'Objects to download'.
  tBlock3 = 'Additional downloads for programs, function modules and classes'.
  tBlock4 = 'Download parameters'.
  tBlock5 = 'Display options'.
  tAuth   = 'Author name'.
  tPmod   = 'Include programs modified by author'.
  tCust   = 'Only customer objects'.
  tNRange = 'Alt customer name range'.
  tRtable = 'Tables / Structures'.
  tPtable = 'Table name'.
  tTnote  = 'Note: tables are stored under the username of the last person who modified them'.
  tRfunc  = 'Function modules'.
  tPfname = 'Function name'.
  tFgroup = 'Function group'.
  tRClass  = 'Classes'.
  tPcname = 'Class name'.
  tMess   = 'Message class'.
  tMName  = 'Class name'.
  tMLang  = 'Language'.
  tProg   = 'Programs'.
  tRpname = 'Program name'.
  tPack   = 'Package'.
  tPtxt   = 'Text document'.
  tPhtml  = 'HTML document'.
  tBack   = 'Include background colour'.
  tPtext  = 'Text elements'.
  tPinc   = 'Include programs'.
  tRecI   = 'Recursive search'.
  tPpath  = 'File path'.
  tSPath  = 'Logical file name'.
  tPmes   = 'Message classes'.
  tPfunc  = 'Function modules'.
  tFDoc    = 'Function module documentation'.
  tCDoc    = 'Class documentation'.
  tRecf   = 'Recursive search'.
  tRecC   = 'Class recursive search'.
  tPscr   = 'Screens'.
  tPdict  = 'Dictionary structures'.
  tSortT  = 'Sort table fields alphabetically'.
  tServ   = 'Download to server'.
  tPc     = 'Download to PC'.
  tRep    = 'Display download report'.
  tProMess  = 'Display progress messages'.

* Determine the frontend operating system type.
  if sy-batch is initial.
    perform determineFrontendOPSystem using frontendSlashSeparator frontendOpSystem.
  endif.
  perform determineServerOpsystem using serverSlashSeparator serverFileSystem serverOpsystem.

* Determine if the external command exists.  If it doesn't then disable the server input field
  perform findExternalCommand using serverFileSystem.


*----------------------------------------------------------------------------------------------------------------------
start-of-selection.
*----------------------------------------------------------------------------------------------------------------------
  perform checkComboBoxes.
  perform fillSelectionRanges.
  startTime = sy-uzeit.

* Don't display status messages if we are running in the background
  if not sy-batch is initial.
    pProMess = ''.
  endif.

* Fool the HTML routines to stop them hyperlinking anything with a space in them
  if pCName is initial.
    customerNameSpace  = '^'.
  else.
    customerNameSpace = pCName.
  endif.

* Set the file extension and output type of the file
  if pTxt is initial.
    downloadFileExtension = HTMLEXTENSION.
  else.
    downloadFileExtension = TEXTEXTENSION.
  endif.

* Determine which operating slash and download directory to use
  case 'X'.
    when pPc.
      slashSeparatorToUse = frontendSlashSeparator.
      downloadFolder = pFolder.
    when pServ.
      slashSeparatorToUse = serverSlashSeparator.
      downloadFolder = serverFolder.
  endcase.

* Main program flow.
  case 'X'.
*   Select tables
    when rTable.
      perform retrieveTables using iDictionary[]
                                   soTableNames[]
                                   soAuthor[]
                                   soPack[].

*   Select message classes tables
    when rMess.
      perform retrieveMessageClass using iMessages[]
                                         soAuthor[]      "Author
                                         pMname          "Message class name
                                         pMLang          "Message class language
                                         pMod            "Modified by author
                                         soPack[].       "Package

*   Select function modules
    when rFunc.
      perform retrieveFunctions using soFunctionName[]   "Function name
                                      soFunctionGroup[]  "Function group
                                      iFunctions[]       "Found functions
                                      soAuthor[]         "Author
                                      pText              "Get text elements
                                      pScr               "Get screens
                                      pCust              "Customer data only
                                      customerNameSpace  "Customer name range
                                      soPack[].             "Package

*       Find Dict structures, messages, functions, includes etc.
        perform scanForAdditionalFuncStuff using iFunctions[]
                                                 pRecI                   "Search for includes recursively
                                                 pRecF                   "Search for functions recursively
                                                 pInc                    "Search for includes
                                                 pFunc                   "Search for functions
                                                 pDict                   "search for dictionary objects
                                                 pMess                   "Search for messages
                                                 pCust                   "Customer data only
                                                 customerNameSpace.      "Customer name range

*   Select Classes
    when rClass.
      perform retrieveClasses using iClasses[]
                                    iFunctions[]
                                    soClassName[]       "Class name
                                    soAuthor[]          "Author
                                    customerNameSpace   "Customer name range
                                    pMod                "Also modified by author
                                    pCust               "Customer object only
                                    pMess               "Find messages
                                    pText               "Text Elements
                                    pDict               "Dictionary structures
                                    pFunc               "Get functions
                                    pInc                "Get includes
                                    pRecF               "Search recursively for functions
                                    pRecI               "Search recursively for includes
                                    pRecC               "Search recursively for classes
                                    pMLang              "Language
                                    soPack[].           "Package

      loop at iFunctions.
*       Find Dict structures, messages, functions, includes etc.
        perform scanForAdditionalFuncStuff using iFunctions[]
                                                 pRecI                   "Search for includes recursively
                                                 pRecF                   "Search for functions recursively
                                                 pInc                    "Search for includes
                                                 pFunc                   "Search for functions
                                                 pDict                   "search for dictionary objects
                                                 pMess                   "Search for messages
                                                 pCust                   "Customer data only
                                                 customerNameSpace.      "Customer name range
      endloop.


*   Select programs
    when rProg.
      perform retrievePrograms using iPrograms[]
                                     iProgFunctions[]
                                     soProgramName[]    "Program name
                                     soAuthor[]         "Author
                                     customerNamespace  "Customer name range
                                     pMod               "Also modified by author
                                     pCust              "Customer object only
                                     pMess              "Find messages
                                     pText              "Text Elements
                                     pDict              "Dictionay structures
                                     pFunc              "Get functions
                                     pInc               "Get includes
                                     pScr               "Get screens
                                     pRecF              "Search recursively for functions
                                     pRecI              "Search recursively for includes
                                     soPack[].             "Package
  endcase.

*----------------------------------------------------------------------------------------------------------------------
end-of-selection.
*----------------------------------------------------------------------------------------------------------------------
  if forcedExit = 0.
*   Decide what to download
    case 'X'.
*     Download tables
      when rTable.
        if not ( iDictionary[] is initial ).
          perform downloadDDStructures using iDictionary[]
                                             iDictFilename[]
                                             downloadFolder
                                             HTMLEXtension
                                             space
                                             pSortT
                                             slashSeparatorToUse
                                             pServ
                                             pProMess
                                             serverFileSystem
                                             pBack.
        endif.

*     Download message class
      when rMess.
        if not ( iMessages[] is initial ).
          sort iMessages ascending by arbgb msgnr.
          loop at iMessages.
            append iMessages to iSingleMessageClass.
            at end of arbgb.
              perform downloadMessageClass using iSingleMessageClass[]
                                                 iMessages-arbgb
                                                 downloadFolder
                                                 downloadFileExtension
                                                 pHtml
                                                 space
                                                 customerNameSpace
                                                 pInc
                                                 pDict
                                                 pMess
                                                 slashSeparatorToUse
                                                 pServ
                                                 pProMess
                                                 serverFileSystem
                                                 pBack.
              clear iSingleMessageClass[].
            endat.
          endloop.
       endif.

*     Download functions
      when rFunc.
        if not ( iFunctions[] is initial ).
           perform downloadFunctions using iFunctions[]
                                           iDictFilename[]
                                           downloadFolder
                                           downloadFileExtension
                                           space
                                           pFDoc
                                           pHtml
                                           customerNameSpace
                                           pInc
                                           pDict
                                           TEXTEXTENSION
                                           HTMLEXTENSION
                                           pSortT
                                           slashSeparatorToUse
                                           pServ
                                           pProMess
                                           serverFileSystem
                                           pBack.
        endif.

*     Download Classes
      when rClass.
        if not ( iClasses[] is initial ).
          perform downloadClasses using iClasses[]
                                        iFunctions[]
                                        iDictFilename[]
                                        downloadFolder
                                        downloadFileExtension
                                        HTMLEXTENSION
                                        TEXTEXTENSION
                                        pHtml
                                        customerNameSpace
                                        pInc
                                        pDict
                                        pCDoc
                                        pSortT
                                        slashSeparatorToUse
                                        pServ
                                        pProMess
                                        serverFileSystem
                                        pBack.
        endif.

*     Download programs
      when rProg.
        if not ( iPrograms[] is initial ).
          perform downloadPrograms using iPrograms[]
                                         iProgFunctions[]
                                         iDictFilename[]
                                         downloadFolder
                                         downloadFileExtension
                                         HTMLEXTENSION
                                         TEXTEXTENSION
                                         pHtml
                                         customerNameSpace
                                         pInc
                                         pDict
                                         '' "Documentation
                                         pSortT
                                         slashSeparatorToUse
                                         pServ
                                         pProMess
                                         serverFileSystem
                                         pBack.
          endif.
    endcase.


*   Free all the memory IDs we may have built up in the program
*   Free up any memory used for caching HTML versions of objects
    perform freeMemory using iPrograms[]
                             iFunctions[]
                             iProgFunctions[]
                             iDictionary[].

    if not pRep is initial.
      get time.
      runTime = sy-uzeit - startTime.

      case 'X'.
        when rTable.
          perform fillTreeNodeTables using iDictionary[]
                                           iTreeDisplay[]
                                           runTime.

        when rMess.
          perform fillTreeNodeMessages using iMessages[]
                                             iTreeDisplay[]
                                             runTime.


        when rFunc.
          perform fillTreeNodeFunctions using iFunctions[]
                                              iTreeDisplay[]
                                              runTime.

        when rClass.
          perform fillTreeNodeClasses using iClasses[]
                                            iFunctions[]
                                            iTreeDisplay[]
                                            runTime.

        when rProg.
          perform fillTreeNodePrograms using iPrograms[]
                                             iProgFunctions[]
                                             iTreeDisplay[]
                                             runTime.
      endcase.

      if not ( iTreeDisplay[] is initial ).
        perform displayTree using iTreeDisplay[].
      else.
        statusBarMessage = 'No items found matching selection criteria'.
        perform displayStatus using statusBarMessage 2.
      endif.
    endif.
  endif.

* Clear out all the internal tables
  clear iPrograms[].
  clear iFunctions[].
  clear iClasses[].
  clear iProgFunctions[].
  clear iMessages[].
  clear iDictionary[].
  clear iDictFilename[].

*--- Memory IDs
* User name
  set parameter id 'MAUTH' field pAuth.
* Message class
  set parameter id 'MMNAME' field pMname.
* Customer namespace
  set parameter id 'MNAMESPACE' field pCName.
* Folder
  set parameter id 'MFOLDER' field pFolder.
* Logical filepath
  set parameter id 'MLOGICAL' field pLogical.
* Text element checkbox
  set parameter id 'MTEXT' field pText.
* Messages checkbox
  set parameter id 'MMESS' field pMess.
* Includes checkbox
  set parameter id 'MINC' field pInc.
* Recursive includes checkbox.
  set parameter id 'MRECI' field pReci.
* Functions checkbox
  set parameter id 'MFUNC' field pFunc.
* Recursive functions checkbox
  set parameter id 'MRECF' field pRecf.
* Recursive classes checkbox
  set parameter id 'MRECF' field pRecC.
* Function module documentation checkbox
  set parameter id 'MFDOC' field pFDoc.
* Class documentation checkbox
  set parameter id 'MCDOC' field pCDoc.
* Screens checkbox
  set parameter id 'MSCR' field pScr.
* Dictionary checkbox
  set parameter id 'MDICT' field pDict.
* Sort table ascending checkBox
  set parameter id 'MSORTT' field pSortT.


***********************************************************************************************************************
***************************************************SUBROUTINES*********************************************************
***********************************************************************************************************************

*----------------------------------------------------------------------------------------------------------------------
*  free memory...
*----------------------------------------------------------------------------------------------------------------------
form freeMemory using iLocPrograms like iPrograms[]
                      iLocFunctions like iFunctions[]
                      iLocProgfunctions like iProgFunctions[]
                      iLocDictionary like iDictionary[].

field-symbols: <wafunction> like line of iLocfunctions.
field-symbols: <waProgram> like line of iLocPrograms.
field-symbols: <waDictStruct> type tDictTable.

  loop at iLocFunctions assigning <waFunction>.
    loop at <waFunction>-iDictStruct assigning <waDictStruct>.
      free memory id <waDictStruct>-tablename.
    endloop.
  endloop.

  loop at iLocProgFunctions assigning <waFunction>.
    loop at <waFunction>-iDictStruct assigning <waDictStruct>.
      free memory id <waDictStruct>-tablename.
    endloop.
  endloop.

  loop at iLocPrograms assigning <waProgram>.
    loop at <waProgram>-iDictStruct assigning <waDictStruct>.
      free memory id <waDictStruct>-tablename.
    endloop.
  endloop.

  loop at iLocDictionary assigning <waDictStruct>.
    free memory id <waDictStruct>-tablename.
  endloop.
endform.


*----------------------------------------------------------------------------------------------------------------------
*  checkComboBoxes...  Check input parameters
*----------------------------------------------------------------------------------------------------------------------
form checkComboBoxes.

  if pAuth is initial.
    if soPack[] is initial.
      case 'X'.
        when rTable.
          if soTable[] is initial.
            statusBarMessage = 'You must enter either a table name or author.'.
          endif.
        when rFunc.
          if ( soFName[] is initial ) and ( soFGroup[] is initial ).
            if soFName[] is initial.
              statusBarMessage = 'You must enter either a function name or author.'.
            else.
              if soFGroup[] is initial.
                statusBarMessage = 'You must enter either a function group, or an author name.'.
              endif.
            endif.
          endif.
        when rProg.
          if soProg[] is initial.
              statusBarMessage = 'You must enter either a program name or author name.'.
          endif.
      endcase.
    endif.
  else.
*   Check the user name of the person objects are to be downloaded for
    if pAuth = 'SAP*' or pauth = 'SAP'.
      statusBarMessage = 'Sorry cannot download all objects for SAP standard user'.
    endif.
  endif.

  if not statusBarMessage is initial.
    perform displayStatus using statusBarMessage 3.
    forcedExit = 1.
    stop.
  endif.
endform.                                                                                "checkComboBoxes

*----------------------------------------------------------------------------------------------------------------------
* fillSelectionRanges...      for selection routines
*----------------------------------------------------------------------------------------------------------------------
form fillSelectionRanges.

data: strLength type i.

  strLength = strlen( pcName ).

  if not pAuth is initial.
    soAuthor-sign = 'I'.
    soAuthor-option = 'EQ'.
    soAuthor-low = pAuth.
    append soAuthor.
  endif.

* Tables
  if not soTable is initial.
    soTableNames[] = soTable[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soTableNames.
        if soTableNames-low+0(strLength) <> pcName.
          concatenate pcName soTableNames-low into soTableNames-low.
        endif.

        if soTableNames-high+0(strLength) <> pcName.
          concatenate pcName soTableNames-high into soTableNames-high.
        endif.

        modify soTableNames.
      endloop.
    endif.
  endif.

* Function names
  if not soFName is initial.
    soFunctionName[] = soFname[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soFunctionName.
        if soFunctionName-low+0(strLength) <> pcName.
          concatenate pcName soFunctionName-low into soFunctionName-low.
        endif.

        if soFunctionName-high+0(strLength) <> pcName.
          concatenate pcName soFunctionName-high into soFunctionName-high.
        endif.

        modify soFunctionName.
      endloop.
    endif.
  endif.

* Function group
  if not soFGroup is initial.
    soFunctionGroup[] = soFGroup[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soFunctionName.
        if soFunctionGroup-low+0(strLength) <> pcName.
          concatenate pcName soFunctionGroup-low into soFunctionGroup-low.
        endif.

        if soFunctionGroup-high+0(strLength) <> pcName.
          concatenate pcName soFunctionGroup-high into soFunctionGroup-high.
        endif.

        modify soFunctionGroup.
      endloop.
    endif.
  endif.

* Class names
  if not soClass is initial.
    soClassName[] = soClass[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soClassName.
        if soClassName-low+0(strLength) <> pcName.
          concatenate pcName soClassName-low into soClassName-low.
        endif.

        if soClassName-high+0(strLength) <> pcName.
          concatenate pcName soClassName-high into soClassName-high.
        endif.

        modify soClassName.
      endloop.
    endif.
  endif.

* Program names
  if not soProg is initial.
    soProgramName[] = soProg[].
*   Add in the customer namespace if we need to
    if not pcName is initial.
       loop at soProgramName.
        if soProgramName-low+0(strLength) <> pcName.
          concatenate pcName soProgramName-low into soProgramName-low.
        endif.

        if soProgramName-high+0(strLength) <> pcName.
          concatenate pcName soProgramName-high into soProgramName-high.
        endif.

        modify soProgramName.
      endloop.
    endif.
  endif.
endform.                                                                                          " fillSelectionRanges

*----------------------------------------------------------------------------------------------------------------------
*  retrieveTables...             Search for tables in dictionary
*----------------------------------------------------------------------------------------------------------------------
form retrieveTables using iLocDictStructure like iDictionary[]
                          soTable like soTable[]
                          soAuthor like soAuthor[]
                          value(soLocPackage) like soPack[].

data: iDictStructure type standard table of tDictTable.
data: waDictStructure type tDictTable.

  select a~tabname as tableName
         into corresponding fields of table iDictStructure
         from dd02l as a
         inner join tadir as b
           on a~tabname = b~obj_name
         where a~tabname in soTable
           and a~tabclass <> 'CLUSTER'
           and a~tabclass <> 'POOL'
           and a~tabclass <> 'VIEW'
           and a~as4user in soAuthor
           and a~as4local = 'A'
           and b~pgmid = 'R3TR'
           and b~object = 'TABL'
           and b~devclass in soLocPackage[].

  loop at iDictStructure into waDictStructure.
    perform findTableDescription using waDictStructure-tablename
                                       waDictStructure-tableTitle.

    perform findTableDefinition using waDictStructure-tableName
                                      waDictStructure-iStructure[].

    append waDictStructure to iLocDictStructure.
    clear waDictStructure.
  endloop.
endform.                                                                                                "retrieveTables

*----------------------------------------------------------------------------------------------------------------------
*  findTableDescription...  Search for table description in dictionary
*----------------------------------------------------------------------------------------------------------------------
form findTableDescription using value(tableName)
                                      tableDescription.

    select single ddtext
                  from dd02t
                  into tableDescription
                  where tabname = tableName
                   and ddlanguage = pMLang.
endform.                                                                                          "findTableDescription

*----------------------------------------------------------------------------------------------------------------------
*  findTableDefinition... Find the structure of a table from the SAP database.
*----------------------------------------------------------------------------------------------------------------------
form findTableDefinition using value(tablename)
                               iDictStruct like dumIDictStructure[].

data gotstate like dcobjif-gotstate.
data: definition type standard table of DD03P with header line.
data: waDictStruct type tDictTableStructure.

  call function 'DDIF_TABL_GET'
       exporting
            name          = tablename
            state         = 'A'
            langu         = pMLang
       importing
            gotstate      = gotstate
       tables
            dd03p_tab     = definition
       exceptions
            illegal_input = 1
            others        = 2.

  if sy-subrc = 0 and gotstate = 'A'.
    loop at definition.
      move-corresponding definition to waDictStruct.
      perform removeLeadingZeros changing waDictStruct-position.
      perform removeLeadingZeros changing waDictStruct-leng.
      append waDictStruct to iDictStruct.
    endloop.
  endif.
endform.                                                                                           "findTableDefinition

*----------------------------------------------------------------------------------------------------------------------
*  retrieveMessageClass...   Retrieve a message class from the SAP database
*----------------------------------------------------------------------------------------------------------------------
form retrieveMessageClass using iLocMessages like iMessages[]
                                rangeAuthor like soAuthor[]
                                value(messageClassName)
                                value(messageClassLang)
                                value(modifiedBy)
                                value(soLocPackage) like soPack[].

data: waMessage type tMessage.
data: iMClasses type standard table of arbgb.


  if not messageClassName is initial.
*   Check to see if the message class exists in the package
    if not soLocPackage[] is initial.
        select obj_name as arbgb
               into table iMClasses
               from tadir
               where pgmid = 'R3TR'
                 and object = 'MSAG'
                 and devclass in soLocPackage.
    endif.

    replace '*' with '%' into messageClassName.
    if iMCLasses[] is initial.
      select t100~arbgb
             t100~text
             t100~msgnr
             t100a~stext
             appending corresponding fields of table iLocMessages
             from t100
             inner join t100a
               on t100a~arbgb = t100~arbgb
             where t100a~masterLang = messageClassLang
               and t100~sprsl = messageClassLang
               and t100~arbgb like messageClassName
               and t100a~respUser in rangeAuthor[].
    else.
      select t100~arbgb
             t100~text
             t100~msgnr
             t100a~stext
             appending corresponding fields of table iLocMessages
             from t100
             inner join t100a
               on t100a~arbgb = t100~arbgb
             for all entries in iMClasses
               where t100~sprsl = messageClassLang
               and ( t100~arbgb like messageClassName and t100~arbgb = iMClasses-table_line )
               and t100a~masterLang = messageClassLang
               and t100a~respUser in rangeAuthor[].
    endif.
  else.
    if modifiedBy is initial.
*       Select by author
        select t100~arbgb                             "#EC CI_BUFFJOIN
               t100~msgnr
               t100~text
               t100a~stext
               appending corresponding fields of table iLocMessages
               from t100
               inner join t100a
                 on t100a~arbgb = t100~arbgb
               inner join tadir
                 on t100~arbgb = tadir~obj_name
               where t100a~masterLang = messageClassLang
                 and t100a~respUser in rangeAuthor[]
                 and tadir~pgmid = 'R3TR'
                 and tadir~object = 'MSAG'
                 and tadir~devclass in soLocPackage[].

    else.
*     Select also by the last person who modified the message class
      select t100~arbgb                             "#EC CI_BUFFJOIN
             t100~msgnr
             t100~text
             t100a~stext
             appending corresponding fields of table iLocMessages
             from t100
             inner join t100a
               on t100a~arbgb = t100~arbgb
             inner join tadir
               on t100~arbgb = tadir~obj_name
             where t100a~masterLang = messageClassLang
               and t100a~respUser in rangeAuthor[]
               and t100a~lastUser in rangeAuthor[]
               and tadir~pgmid = 'R3TR'
               and tadir~object = 'MSAG'
               and tadir~devclass in soLocPackage[].
    endif.
  endif.
endform.                                                                                          "retrieveMessageClass


*----------------------------------------------------------------------------------------------------------------------
*  retrieveFunctions...   Retrieve function modules from SAP DB.  May be called in one of two ways
*----------------------------------------------------------------------------------------------------------------------
form retrieveFunctions using soFName like soFunctionName[]
                             soFGroup like soFunctionGroup[]
                             iLocFunctionNames like iFunctions[]
                             value(solocAuthor) like soAuthor[]
                             value(getTextElements)
                             value(getScreens)
                             value(customerOnly)
                             value(customerNameRange)
                             value(soLocPackage) like soPack[].


data: waFunctionName type tFunction.
data: noGroupsFound type abap_bool value TRUE.
data: previousFG type v_fdir-area.

* select by function name and/or function group.
  select a~funcName as functionName
         a~area as functionGroup
         into corresponding fields of table iLocfunctionNames
         from v_fdir as a
         inner join tlibv as b
           on a~area = b~area
         inner join tadir as c
           on a~area = c~obj_name
         where a~funcName in soFName[]
           and a~area in soFGroup[]
           and a~generated = ''
           and b~uname in soLocAuthor[]
           and pgmid = 'R3TR'
           and object = 'FUGR'
           and devclass in solocPackage[]
           order by a~area.

  loop at iLocFunctionNames into waFunctionName.
    perform retrieveFunctionDetail using waFunctionName-functionName
                                         waFunctionName-progname
                                         waFunctionName-includeNumber
                                         waFunctionName-functionTitle.

    perform findMainFunctionInclude using waFunctionName-progname
                                          wafunctionName-functionGroup
                                          waFunctionName-includeNumber
                                          waFunctionName-functionMainInclude.

    perform findFunctionTopInclude using waFunctionName-progname
                                         wafunctionName-functionGroup
                                         waFunctionName-topIncludeName.

*   Find all user defined includes within the function group
    perform scanForFunctionIncludes using waFunctionName-progname
                                          customerOnly
                                          customerNameRange
                                          waFunctionName-iIncludes[].
*   Find main message class
    perform findMainMessageClass using waFunctionName-progname
                                       waFunctionName-messageClass.

*   Find any screens declared within the main include
    if not getScreens is initial.
      if previousFG is initial or previousFG <> waFunctionName-functionGroup.
        perform findFunctionScreenFlow using waFunctionName.

*       Search for any GUI texts
        perform retrieveGUITitles using waFunctionName-iGUITitle[]
                                        waFunctionName-progname.
      endif.
    endif.

    if not getTextElements is initial.
*     Find the program texts from out of the database.
      perform retrieveProgramTexts using waFunctionName-iSelectionTexts[]
                                         waFunctionName-iTextElements[]
                                         waFunctionName-progname.
    endif.

    previousFG = waFunctionName-functionGroup.
    modify iLocFunctionNames from waFunctionName.
  endloop.
endform.                                                                                             "retrieveFunctions

*----------------------------------------------------------------------------------------------------------------------
*  retrieveFunctionDetail...   Retrieve function module details from SAP DB.
*----------------------------------------------------------------------------------------------------------------------
form retrieveFunctionDetail using value(functionName)
                                        progname
                                        includeName
                                        titleText.

  select single pname
                include
                from tfdir
                into (progname, includeName)
                where funcName = functionName.

  if sy-subrc = 0.
    select single stext
                  from tftit
                  into titleText
                  where spras = pMLang
                    and funcName = functionName.
  endif.
endform.                                                                                        "retrieveFunctionDetail                                                                                  "findFunctionTopInclude

*----------------------------------------------------------------------------------------------------------------------
* scanForAdditionalFuncStuff... Search for additional things relating to functions
*----------------------------------------------------------------------------------------------------------------------
form scanForAdditionalFuncStuff using iLocFunctions like iFunctions[]
                                      value(recursiveIncludes)
                                      value(recursiveFunctions)
                                      value(searchForIncludes)
                                      value(searchForFunctions)
                                      value(searchForDictionary)
                                      value(searchForMessages)
                                      value(customerOnly)
                                      value(customerNameRange).

data: waFunction type tFunction.
data: waInclude type tInclude.

  loop at iLocFunctions into waFunction.
    if not searchForIncludes is initial.
*     Search in the main include
      perform scanForIncludePrograms using waFunction-functionMainInclude
                                           recursiveIncludes
                                           customerOnly
                                           customerNameRange
                                           waFunction-iIncludes[].

*     Search in the top include
      perform scanForIncludePrograms using waFunction-topIncludeName
                                           recursiveIncludes
                                           customerOnly
                                           customerNameRange
                                           waFunction-iIncludes[].
    endif.

    if not searchForFunctions is initial.
      perform scanForFunctions using waFunction-functionMainInclude
                                     waFunction-programLinkName
                                     recursiveIncludes
                                     recursiveFunctions
                                     customerOnly
                                     customerNameRange
                                     iLocFunctions[].
    endif.

    modify iLocFunctions from waFunction.
  endloop.

* Now we have everthing perhaps we had better find all the dictionary structures
  if not searchForDictionary is initial.
    loop at iLocFunctions into waFunction.
      perform scanForTables using waFunction-progname
                                  customerOnly
                                  customerNameRange
                                  waFunction-iDictStruct[].

      perform scanForLikeOrType using waFunction-progname
                                      customerOnly
                                      customerNameRange
                                      waFunction-iDictStruct[].

      perform scanForTables using waFunction-functionMainInclude
                                  customerOnly
                                  customerNameRange
                                  waFunction-iDictStruct[].

      perform scanForLikeOrType using waFunction-functionMainInclude
                                      customerOnly
                                      customerNameRange
                                      waFunction-iDictStruct[].

      loop at waFunction-iIncludes into waInclude.
        perform scanForTables using waInclude-includeName
                                    customerOnly
                                    customerNameRange
                                    waFunction-iDictStruct[].

        perform scanForLikeOrType using waInclude-includeName
                                        customerOnly
                                        customerNameRange
                                        waFunction-iDictStruct[].
      endloop.

    modify iLocFunctions from waFunction.
    endloop.
  endif.

* Now search for all messages
  if not searchForMessages is initial.
    loop at iLocFunctions into waFunction.
      perform scanForMessages using waFunction-progName
                                    waFunction-messageClass
                                    waFunction-iMessages[].
    modify iLocFunctions from waFunction.
    endloop.
  endif.
endform.                                                                                    "scanForAdditionalFuncStuff

*----------------------------------------------------------------------------------------------------------------------
* scanForClasses... Search each class or method for other classes
*----------------------------------------------------------------------------------------------------------------------
form scanForClasses using value(className)
                          value(classLinkName)
                          value(customerOnly)
                          value(customerNameRange)
                                iLocClasses like iClasses[]
                          value(soLocPackage) like soPack[].

data iLines type standard table of string with header line.
data: head type string.
data: tail type string.
data: lineLength type i value 0.
data: waLine type string.
data: waClass type tClass.
data: waSearchClass type tClass.
data: castClassName type program.
data: exceptionCustomerNameRange type string.

* Build the name of the possible cusotmer exception classes
  concatenate customerNameRange 'CX_' into  exceptionCustomerNameRange.

* Read the program code from the textpool.
  castClassName = className.
  read report castClassName into iLines.

  loop at iLines into waLine.
*   Find custom tables.
    lineLength = strLen( waLine ).
    if lineLength > 0.
      if waLine(1) = ASTERIX.
        continue.
      endif.

      translate waLine to upper case.

      find TYPEREFTO in waLine ignoring case.
      if sy-subrc = 0.
*       Have found a reference to another class
        split waLine at TYPE into head tail.
        shift tail left deleting leading space.
        split tail at 'REF' into head tail.
        shift tail left deleting leading space.
        split tail at 'TO' into head tail.
        shift tail left deleting leading space.
        if tail cs PERIOD.
          split tail at PERIOD into head tail.
        else.
          if tail cs COMMA.
            split tail at COMMA into head tail.
          endif.
        endif.
      else.
*       Try and find classes which are only referenced through static mehods
        find '=>' in waLine match offset sy-fdpos.
        if sy-subrc = 0.
          head = waline+0(sy-fdpos).
          shift head left deleting leading space.
          condense head.
          find 'call method' in head ignoring case.
          if sy-subrc = 0.
            shift head left deleting leading space.
            split head at space into head tail.
            split tail at space into head tail.
*           Should have the class name here
            head = tail.
          else.
*           Still have a class name even though it does not have the words call method in front
            if waLine cs '='.
              split waLine at '=' into tail head.
              shift head left deleting leading space.
              split head at '=' into head tail.
            endif.
            sy-subrc = 0.
          endif.
        endif.
      endif.

      if sy-subrc = 0.
        try.
          if head+0(1) = 'Y' or head+0(1) = 'Z' or head cs customerNameRange.
*           We have found a class best append it to our class table if we do not already have it.
            read table iLocClasses into waSearchClass with key clsName = head.
            if sy-subrc <> 0.
              if head+0(3) = 'CX_'
                 or head+0(4) = 'ZCX_'
                 or head+0(4) = 'YCX_'
                 or head cs exceptionCustomerNameRange.

                waClass-exceptionClass = TRUE.
              endif.

              waClass-clsname = head.

*             Check the package
              if not soLocPackage[] is initial.
                select single obj_name
                       from tadir
                       into waClass-clsName
                       where pgmid = 'R3TR'
                         and object = 'CLAS'
                         and obj_name = waClass-clsName
                         and devclass in soLocPackage[].
                if sy-subrc = 0.
                  append waClass to iLocClasses.
                endif.
              else.
                append waClass to iLocClasses.
              endif.
            endif.
          endif.
          catch cx_sy_range_out_of_bounds.
        endtry.
      endif.
    endif.
  endloop.
endform.                                                                                                "scanForClasses

*----------------------------------------------------------------------------------------------------------------------
* scanForIncludePrograms... Search each program for include programs
*----------------------------------------------------------------------------------------------------------------------
form scanForIncludePrograms using value(programName)
                                  value(recursiveIncludes)
                                  value(customerOnly)
                                  value(customerNameRange)
                                        iLocIncludes like dumiIncludes[].

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iKeywords type standard table of text20 with header line.
data: iStatements type standard table of sstmnt with header line.
data: waTokens type stokes.
data: waInclude type tInclude.
data: waIncludeExists type tInclude.
data: maxLines type i.
data: nextLine type i.
data: castProgramName type program.

* Read the program code from the textpool.
  castProgramName = programName.
  read report castProgramName into iIncludeLines.

  append INCLUDE to iKeywords.
  scan abap-source iIncludeLines tokens into iTokens with includes statements into iStatements keywords from iKeywords.

  clear iIncludeLines[].

  maxLines = lines( iTokens ).
  loop at iTokens where str = INCLUDE and type = 'I'.
     nextLine = sy-tabix + 1.
     if nextLine <= maxLines.
       read table iTokens index nextLine into waTokens.

*      Are we only to find customer includes?
       if not customerOnly is initial.
         try.
           if waTokens-str+0(1) = 'Y' or waTokens-str+0(1) = 'Z' or waTokens-str cs customerNameRange
              or waTokens-str+0(2) = 'MZ' or waTokens-str+0(2) = 'MY'.

           else.
             continue.
           endif.
           catch cx_sy_range_out_of_bounds into objRuntimeError.
         endtry.
       endif.

       waInclude-includeName = waTokens-str.

*      Best find the program title text as well.
       perform findProgramOrIncludeTitle using waInclude-includeName
                                               waInclude-includeTitle.

*      Don't append the include if we already have it listed
       read table iLocIncludes into waIncludeExists with key includeName = waInclude-includeName.
       if sy-subrc <> 0.
         append waInclude to iLocIncludes.

         if not recursiveIncludes is initial.
*          Do a recursive search for other includes
           perform scanForIncludePrograms using waInclude-includeName
                                                recursiveIncludes
                                                customerOnly
                                                customerNameRange
                                                iLocIncludes[].
         endif.
       endif.
     endif.
   endloop.
endform.                                                                                        "scanForIncludePrograms

*----------------------------------------------------------------------------------------------------------------------
* scanForFunctions... Search each program for function modules
*----------------------------------------------------------------------------------------------------------------------
form scanForFunctions using value(programName)
                            value(programLinkName)
                            value(recursiveIncludes)
                            value(recursiveFunctions)
                            value(customerOnly)
                            value(customerNameRange)
                                  iLocFunctions like iFunctions[].

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iStatements type standard table of sstmnt with header line.
data: waTokens type stokes.
data: waFunction type tFunction.
data: waFunctionComparison type tFunction.
data: maxLines type i.
data: nextLine type i.
data: castProgramName type program.
data: skipThisloop type abap_bool.

* Read the program code from the textpool.
  castProgramName = programName.
  read report castProgramName into iIncludeLines.
  scan abap-source iIncludeLines tokens into iTokens with includes statements into iStatements.
  clear iIncludeLines[].

  maxLines = lines( iTokens ).
  loop at iTokens where str = FUNCTION and type = 'I'.

     nextLine = sy-tabix + 1.
     if nextLine <= maxLines.
       read table iTokens index nextLine into waTokens.

*      Are we only to find customer functions
       skipThisLoop = FALSE.
       if not customerOnly is initial.
         try.
           if waTokens-str+1(1) = 'Y' or waTokens-str+1(1) = 'Z' or waTokens-str cs customerNameRange.
           else.
             skipThisLoop = TRUE.
           endif.
         catch cx_sy_range_out_of_bounds into objRuntimeError.
         cleanup.
           skipThisLoop = TRUE.
         endtry.
       endif.

       if skipThisLoop = FALSE.
         waFunction-functionName = waTokens-str.
         replace all occurrences of '''' in waFunction-functionName with ' '.
         condense waFunction-functionName.

*        Don't add a function if we alread have it listed.
         read table iLocFunctions with key functionName = waFunction-functionName into waFunctionComparison.
         if sy-subrc <> 0.
*          Add in the link name if the function is linked to a program
           waFunction-programLinkName = programLinkName.

*          Don't download functions which are called through an RFC destination
           nextline = sy-tabix + 2.
           read table iTokens index nextLine into waTokens.
           if waTokens-str <> DESTINATION.

*            Find the function group
             select single area from v_fdir into wafunction-functionGroup where funcName = waFunction-functionName.

             if sy-subrc = 0.
*              Best find the function number as well.
               perform retrieveFunctionDetail using waFunction-functionName
                                                    waFunction-progname
                                                    waFunction-includeNumber
                                                    waFunction-functionTitle.

               perform findMainFunctionInclude using waFunction-progname
                                                     waFunction-functionGroup
                                                     waFunction-includeNumber
                                                     waFunction-functionMainInclude.

               perform findFunctionTopInclude using waFunction-progname
                                                    wafunction-functionGroup
                                                    waFunction-topIncludeName.


*              Find main message class
               perform findMainMessageClass using waFunction-progname
                                                  waFunction-messageClass.

               append waFunction to iLocFunctions.

*              Now lets search a little bit deeper and do a recursive search for other includes
               if not recursiveIncludes is initial.
                 perform scanForIncludePrograms using waFunction-functionMainInclude
                                                      recursiveIncludes
                                                      customerOnly
                                                      customerNameRange
                                                      waFunction-iIncludes[].
               endif.

*              Now lets search a little bit deeper and do a recursive search for other functions
               if not recursiveFunctions is initial.
                 perform scanForFunctions using waFunction-functionMainInclude
                                                space
                                                recursiveIncludes
                                                recursiveFunctions
                                                customerOnly
                                                customerNameRange
                                                iLocFunctions[].
               endif.
               clear waFunction.
             endif.
           endif.
         endif.

         clear waFunction.
       endif.
     endif.
   endloop.
endform.                                                                                              "scanForFunctions

*----------------------------------------------------------------------------------------------------------------------
*  scanForFunctionIncludes... Find all user defined includes within the function group
*----------------------------------------------------------------------------------------------------------------------
form scanForFunctionIncludes using poolName
                                   value(customerOnly)
                                   value(customerNameRange)
                                   iLocIncludes like dumiIncludes[].

data: iIncludeLines type standard table of string with header line.
data: iTokens type standard table of stokes with header line.
data: iKeywords type standard table of text20 with header line.
data: iStatements type standard table of sstmnt with header line.
data: waTokens type stokes.
data: waInclude type tInclude.
data: waIncludeExists type tInclude.
data: maxLines type i.
data: nextLine type i.
data: castProgramName type program.

* Read the program code from the textpool.
  castProgramName = poolName.
  read report castProgramName into iIncludeLines.

  append INCLUDE to iKeywords.
  scan abap-source iIncludeLines tokens into iTokens with includes statements into iStatements keywords from iKeywords.

  clear iIncludeLines[].

  maxLines = lines( iTokens ).
  loop at iTokens where str = INCLUDE and type = 'I'.
     nextLine = sy-tabix + 1.
     if nextLine <= maxLines.
       read table iTokens index nextLine into waTokens.

       if waTokens-str cp '*F++'.
*        Are we only to find customer includes?
         if not customerOnly is initial.
           try.
             if waTokens-str+0(2) = 'LY' or waTokens-str+0(2) = 'LZ' or waTokens-str cs customerNameRange.
             else.
               continue.
             endif.
             catch cx_sy_range_out_of_bounds into objRuntimeError.
           endtry.
         endif.

         waInclude-includeName = waTokens-str.

*        Best find the program title text as well.
         perform findProgramOrIncludeTitle using waInclude-includeName
                                                 waInclude-includeTitle.


*        Don't append the include if we already have it listed
         read table iLocIncludes into waIncludeExists with key includeName = waInclude-includeName.
         if sy-subrc <> 0.
           append waInclude to iLocIncludes.
         endif.
       endif.
     endif.
   endloop.
endform.                                                                                       "scanForFunctionIncludes

*----------------------------------------------------------------------------------------------------------------------
*  findProgramOrIncludeTitle...   Finds the title text of a program.
*----------------------------------------------------------------------------------------------------------------------
form findProgramOrIncludeTitle using value(programName)
                                           titleText.

  select single text
                from trdirt
                into titleText
                where name = programName
                  and sprsl = pMLang.
endform.                                                                                     "findProgramOrIncludeTitle

*----------------------------------------------------------------------------------------------------------------------
* retrievePrograms...    find programs and sub objects from SAP DB
*----------------------------------------------------------------------------------------------------------------------
form retrievePrograms using iLocProgram like iPrograms[]
                            iLocFunctions like iFunctions[]
                            rangeProgram like soProgramName[]
                            rangeAuthor like soAuthor[]
                            value(custNameRange)
                            value(alsoModifiedByauthor)
                            value(customerProgsOnly)
                            value(getMessages)
                            value(getTextElements)
                            value(getCustDictStructures)
                            value(getFunctions)
                            value(getIncludes)
                            value(getScreens)
                            value(recursiveFuncSearch)
                            value(recursiveIncludeSearch)
                            value(soLocPackage) like soPack[].

data: waRangeProgram like line of rangeProgram.

  if rangeProgram[] is initial.
*   We are finding all programs by an author
    perform findAllProgramsForAuthor using iLocProgram[]
                                           rangeProgram[]
                                           rangeAuthor[]
                                           custNameRange
                                           alsoModifiedByAuthor
                                           customerProgsOnly
                                           soLocPackage[].
  else.
    read table rangeProgram index 1 into waRangeProgram.
    if waRangeProgram-low cs ASTERIX.
      perform findProgramsByWildcard using iLocProgram[]
                                           rangeProgram[]
                                           rangeAuthor[]
                                           custNameRange
                                           customerProgsOnly
                                           soLocPackage[].
    else.
      perform checkProgramDoesExist using iLocProgram[]
                                          rangeProgram[].
    endif.
  endif.

* Find extra items
  perform scanForAdditionalProgStuff using iLocProgram[]
                                           iLocFunctions[]
                                           getTextElements
                                           getMessages
                                           getScreens
                                           getCustDictStructures
                                           getFunctions
                                           getIncludes
                                           customerProgsOnly
                                           custNameRange
                                           recursiveIncludeSearch
                                           recursiveFuncSearch.
endform.                                                                               "retrievePrograms

*-------------------------------------------------------------------------------------------------------
*  scanForAdditionalProgStuff...
*-------------------------------------------------------------------------------------------------------
form scanForAdditionalProgStuff using iLocProgram like iPrograms[]
                                      iLocFunctions like iFunctions[]
                                      value(getTextElements)
                                      value(getMessages)
                                      value(getScreens)
                                      value(getCustDictStructures)
                                      value(getFunctions)
                                      value(getIncludes)
                                      value(customerOnly)
                                      value(customerNameRange)
                                      value(recursiveIncludeSearch)
                                      value(recursiveFuncSearch).

data: waProgram type tProgram.
data: waInclude type tInclude.
data: myTabix type syTabix.

* Best to find all the includes used in a program first
  if not getIncludes is initial.
    loop at iLocProgram into waProgram.
      myTabix = sy-tabix.
      perform scanForIncludePrograms using waProgram-progName
                                           recursiveIncludeSearch
                                           customerOnly
                                           customerNameRange
                                           waProgram-iIncludes[].

      modify iLocProgram from waProgram index myTabix.
    endloop.
  endif.

* Once we have a list of all the includes we need to loop round them an select all the other objects
  loop at iLocProgram into waProgram.
    myTabix = sy-tabix.
    perform findProgramDetails using waProgram-progName
                                     waProgram-subc
                                     waProgram-programTitle
                                     waProgram
                                     getTextElements
                                     getMessages
                                     getScreens
                                     getCustDictStructures
                                     customerOnly
                                     customerNameRange.

*   Find any screens
    if not getScreens is initial.
      perform findProgramScreenFlow using waProgram.
    endif.

    loop at waProgram-iIncludes into waInclude.
      perform findProgramDetails using waInclude-includeName
                                       'I'
                                       waInclude-includeTitle
                                       waProgram
                                       getTextElements
                                       getMessages
                                       getScreens
                                       getCustDictStructures
                                       customerOnly
                                       customerNameRange.
    endloop.

    modify iLocProgram from waProgram index myTabix.
  endloop.

* Now we have all the program includes and details we need to find extra functions
  if not getFunctions is initial.
    loop at iLocProgram into waProgram.
*     Find any functions defined in the code
      perform scanForFunctions using waProgram-progname
                                     waProgram-progname
                                     space
                                     space
                                     customerOnly
                                     customerNameRange
                                     iLocFunctions[].
    endloop.
  endif.

* We have a list of all the functions so lets go and find details and other function calls
  perform scanForAdditionalFuncStuff using iLocFunctions[]
                                           recursiveIncludeSearch
                                           recursiveFuncSearch
                                           getIncludes
                                           getFunctions
                                           getCustDictStructures
                                           getMessages
                                           customerOnly
                                           customerNameRange.
endform.                                                                     "scanForAdditionalProgStuff


*-------------------------------------------------------------------------------------------------------
*  findProgramDetails...
*-------------------------------------------------------------------------------------------------------
form findProgramDetails using value(programName)
                              value(programType)
                                    programTitle
                                    waProgram type tProgram
                              value(getTextElements)
                              value(getMessages)
                              value(getScreens)
                              value(getCustDictStructures)
                              value(customerOnly)
                              value(customerNameRange).

  perform findProgramOrIncludeTitle using programName
                                          programTitle.

  if not getTextElements is initial.
*   Find the program texts from out of the database.
    perform retrieveProgramTexts using waProgram-iSelectionTexts[]
                                       waProgram-iTextElements[]
                                       programName.
  endif.

* Search for any GUI texts
  if not getScreens is initial and ( programType = 'M' or programType = '1' ).
    perform retrieveGUITitles using waProgram-iGUITitle[]
                                    programName.
  endif.

* Find individual messages
  if not getMessages is initial.
    if programType = 'M' or programType = '1'.
      perform findMainMessageClass using programName
                                         waProgram-messageClass.
    endif.

    perform scanForMessages using programName
                                  waProgram-messageClass
                                  waProgram-iMessages[].
  endif.

  if not getCustDictStructures is initial.
    perform scanForTables using programName
                                customerOnly
                                customerNameRange
                                waProgram-iDictStruct[].

    perform scanForLikeOrType using programName
                                    customerOnly
                                    customerNameRange
                                    waProgram-iDictStruct[].
  endif.
endform.                                                                             "findProgramDetails

*-------------------------------------------------------------------------------------------------------
*  findAllProgramsForAuthor...
*-------------------------------------------------------------------------------------------------------
form findAllProgramsForAuthor using iLocProgram like iPrograms[]
                                    rangeProgram like soProgramName[]
                                    rangeAuthor like soAuthor[]
                                    value(custNameRange)
                                    value(alsoModifiedByauthor)
                                    value(customerProgsOnly)
                                    value(soLocPackage) like soPack[].

data: altCustomerNameRange type string.
field-symbols: <waProgram> type tProgram.
data: genFlag type genFlag.

* build up the customer name range used for select statements
  concatenate custNameRange '%' into altCustomerNameRange.

* select by name and author
  if not alsoModifiedByAuthor is initial.
*   Programs modified by author
*   Program to search for is an executable program
    if customerProgsOnly is initial.
*     Select all programs
      select a~progname
             a~subc
             appending corresponding fields of table ilocProgram
             from reposrc as a
             inner join tadir as b
               on a~progname = b~obj_name
             where a~progname in rangeProgram
               and a~cnam in rangeAuthor
               and ( a~subc = '1' or a~subc = 'M' or a~subc = 'S' )
               and b~pgmid = 'R3TR'
               and b~object = 'PROG'
               and b~devclass in soLocPackage.

    else.
*     Select only customer specific programs
      select progname
             subc
             appending corresponding fields of table iLocProgram
             from reposrc as a
             inner join tadir as b
               on a~progname = b~obj_name
             where a~progname  in rangeProgram
               and ( a~progname like altCustomerNameRange
                     or a~progname like 'Z%'
                     or a~progname like 'Y%'
                     or a~progname like 'SAPMZ%'
                     or a~progname like 'SAPMY%')
               and a~cnam in rangeAuthor
               and ( a~subc = '1' or a~subc = 'M' or a~subc = 'S' )
               and b~pgmid = 'R3TR'
               and b~object = 'PROG'
               and b~devclass in soLocPackage.
    endif.
  else.

*   Programs created by author
    if customerProgsOnly is initial.
*     Select all programs
      select progname
             subc
             appending corresponding fields of table iLocProgram
             from reposrc as a
             inner join tadir as b
               on a~progname = b~obj_name
             where a~progname in rangeProgram
               and ( a~subc = '1' or a~subc = 'M' or a~subc = 'S' )
               and ( a~cnam in rangeAuthor or a~unam in rangeAuthor )
               and b~pgmid = 'R3TR'
               and b~object = 'PROG'
               and b~devclass in soLocPackage.
    else.
*     Select only customer specific programs
      select a~progname
             a~subc
             appending corresponding fields of table iLocProgram
             from reposrc as a
             inner join tadir as b
               on a~progname = b~obj_name
             where a~progname in rangeProgram
               and ( a~progname like altCustomerNameRange
                     or a~progname like 'Z%'
                     or a~progname like 'Y%'
                     or a~progname like 'SAPMZ%'
                     or a~progname like 'SAPMY%')
               and ( a~subc = '1' or a~subc = 'M' or a~subc = 'S' )
               and ( a~cnam in rangeAuthor or a~unam in rangeAuthor )
               and b~pgmid = 'R3TR'
               and b~object = 'PROG'
               and b~devclass in soLocPackage.
    endif.
  endif.
endform.                                                                       "findAllProgramsForAuthor

*-------------------------------------------------------------------------------------------------------
*  findProgramsByWildcard.. Search in the system for programs
*-------------------------------------------------------------------------------------------------------
form findProgramsByWildcard using iLocProgram like iPrograms[]
                                  value(rangeProgram) like soProgramName[]
                                  value(rangeAuthor) like soAuthor[]
                                  value(custNameRange)
                                  value(customerProgsOnly)
                                  value(soLocPackage) like soPack[].

data: altCustomerNameRange type string.
field-symbols: <waProgram> type tProgram.
data: genFlag type genFlag.

  if customerProgsOnly is initial.
*   build up the customer name range used for select statements
    if custNameRange <> '^'.
      concatenate custNameRange '%' into altCustomerNameRange.

      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
               and progname like altCustomerNameRange
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    else.
      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    endif.
  else.
*   Only customer programs
    if custNameRange <> '^'.
      concatenate custNameRange '%' into altCustomerNameRange.

      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
               and ( progname like altCustomerNameRange
                     or progname like 'Z%'
                     or progname like 'Y%'
                     or progname like 'SAPMZ%'
                     or progname like 'SAPMY%')
               and ( subc = '1' or subc = 'M' or subc = 'S' )
               and ( cnam in rangeAuthor or unam in rangeAuthor ).
    else.
      select progname
             subc
             from reposrc
             appending corresponding fields of table iLocProgram
             where progname  in rangeProgram
             and ( progname like 'Z%'
                   or progname like 'Y%'
                   or progname like 'SAPMZ%'
                   or progname like 'SAPMY%')
             and ( subc = '1' or subc = 'M' or subc = 'S' )
             and ( cnam in rangeAuthor or unam in rangeAuthor ).
    endif.
  endif.
endform.                                                                         "findProgramsByWildcard

*-------------------------------------------------------------------------------------------------------
*  retrieveProgramTexts... Find the text elements and selection texts for a program
*-------------------------------------------------------------------------------------------------------
form retrieveProgramTexts using iLocSelectionTexts like dumiTextTab[]
                                iLocTextElements like dumiTextTab[]
                                value(programName).

data: iTextTable type standard table of tTextTable with header line.
data: waTexts type tTextTable.
data: castProgramName(50).

  move programName to castProgramName.

  read textpool castProgramName into iTextTable language pMLang.
  delete iTextTable where key = 'R'.

* Selection texts.
  loop at iTextTable where id = 'S'.
    move iTextTable-key to waTexts-key.
    move iTextTable-entry to waTexts-entry.
    append waTexts to iLocSelectiontexts.
    clear waTexts.
  endloop.

* Text elements.
  delete iTextTable where key = 'S'.
  loop at iTextTable where id = 'I'.
    move iTextTable-key to waTexts-key.
    move iTextTable-entry to waTexts-entry.
    append waTexts to iLocTextElements.
  endloop.
endform.                                                                           "retrieveProgramTexts

*-------------------------------------------------------------------------------------------------------
*  retrieveGUITitles...  Search for any GUI texts
*-------------------------------------------------------------------------------------------------------
form retrieveGUITitles using iLocGUITitle like dumIGUITitle[]
                             value(programName).

  select obj_code
         text
         from d347t
         appending corresponding fields of table iLocGUItitle
         where progname = programName.
endform.                                                                              "retrieveGUITitles

*-------------------------------------------------------------------------------------------------------
*   findMainMessageClass... find the message class stated at the top of  program.
*-------------------------------------------------------------------------------------------------------
form findMainMessageClass using value(programName)
                                      messageClass.

  select single msgid
                from trdire into messageClass
                where report = programName.
endform.                                                                           "findMainMessageClass

*-------------------------------------------------------------------------------------------------------
* retrieveClasses...    find classes and sub objects from SAP DB
*-------------------------------------------------------------------------------------------------------
form retrieveClasses using iLocClasses like iClasses[]
                           iLocFunctions like iFunctions[]
                           rangeClass like soClassName[]
                           rangeAuthor like soAuthor[]
                           value(custNameRange)
                           value(alsoModifiedByauthor)
                           value(customerProgsOnly)
                           value(getMessages)
                           value(getTextElements)
                           value(getCustDictStructures)
                           value(getFunctions)
                           value(getIncludes)
                           value(recursiveFuncSearch)
                           value(recursiveIncludeSearch)
                           value(recursiveClassSearch)
                           value(language)
                           value(soLocPackage) like soPack[].

data: waRangeClass like line of rangeClass.
data: waClass like line of iLocCLasses[].

  if rangeClass[] is initial.
*   We are finding all programs by an author
    perform findAllClassesForAuthor using iLocClasses[]
                                           rangeClass[]
                                           rangeAuthor[]
                                           custNameRange
                                           alsoModifiedByAuthor
                                           customerProgsOnly
                                           language.
  else.
    read table rangeClass index 1 into waRangeClass.
    if waRangeClass-low cs ASTERIX.
      perform findClassesByWildcard using iLocClasses[]
                                          rangeClass[]
                                          rangeAuthor[]
                                          custNameRange
                                          customerProgsOnly
                                          language.
    else.
      perform checkClassDoesExist using iLocClasses[]
                                        rangeClass[].
    endif.
  endif.

* Check the package
  if not soLocPackage[] is initial.
    loop at iLocClasses into waClass.
      select single obj_name
             from tadir
             into waClass-clsName
             where pgmid = 'R3TR'
               and object = 'CLAS'
               and obj_name = waClass-clsName
               and devclass in soLocPackage[].
      if sy-subrc <> 0.
        delete iLocClasses.
      endif.
    endloop.
  endif.

* Find extra items
  if not iLocClasses[] is initial.
    perform scanForAdditionalClassStuff using iLocClasses[]
                                              iLocFunctions[]
                                              getTextElements
                                              getMessages
                                              getCustDictStructures
                                              getFunctions
                                              getIncludes
                                              customerProgsOnly
                                              custNameRange
                                              recursiveIncludeSearch
                                              recursiveFuncSearch
                                              recursiveClassSearch
                                              soLocPackage[].
  endif.
endform.                                                                                "retrieveClasses
*-------------------------------------------------------------------------------------------------------
*  findAllClassesForAuthor...
*-------------------------------------------------------------------------------------------------------
form findAllClassesForAuthor using iLocClass like iClasses[]
                                   rangeClass like soClassName[]
                                   rangeAuthor like soAuthor[]
                                   value(custNameRange)
                                   value(alsoModifiedByauthor)
                                   value(customerClassesOnly)
                                   value(language).

data: altCustomerNameRange type string.

* build up the customer name range used for select statements
  concatenate custNameRange '%' into altCustomerNameRange.

* select by name and author
  if not alsoModifiedByAuthor is initial.
*   Classes modified by author
    if customerClassesOnly is initial.
*     Select all classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
               and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Select only customer specific classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and ( clsname like altCustomerNameRange
                     or clsname like 'Z%'
                     or clsname like 'Y%')
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and ( clsname like altCustomerNameRange
                       or clsname like 'Z%'
                       or clsname like 'Y%')
                 and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  else.
*   Programs created by author
    if customerClassesOnly is initial.
*     Select all classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and langu = language
               and author in rangeAuthor
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and langu = language
                 and author in rangeAuthor
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Select only customer specific classes
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and ( clsname like altCustomerNameRange
                     or clsname like 'Z%'
                     or clsname like 'Y%')
               and langu = language
               and author in rangeAuthor
               and version = '1'
               and ( state = '0' or state = '1' ).

      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and ( clsname like altCustomerNameRange
                       or clsname like 'Z%'
                       or clsname like 'Y%')
                 and langu = language
                 and author in rangeAuthor
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  endif.
endform.                                                                        "findAllClassesForAuthor

*-------------------------------------------------------------------------------------------------------
*  findClassesByWildcard...  Find classes using a wildcard search
*-------------------------------------------------------------------------------------------------------
form findClassesByWildcard using iLocClass like iClasses[]
                                 rangeClass like soClassName[]
                                 value(rangeAuthor) like soAuthor[]
                                 value(custNameRange)
                                 value(customerClassesOnly)
                                 value(language).

data: altCustomerNameRange type string.

  if customerClassesOnly is initial.
*   Searching for customer and SAP classes
    if custNameRange <> '^'.
*     build up the customer name range used for select statements
      concatenate custNameRange '%' into altCustomerNameRange.

      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and clsname like custNameRange
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and clsname like custNameRange
                 and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Searching using normal name ranges
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and langu = language
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and langu = language
                 and ( author in rangeAuthor or changedby in rangeAuthor )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  else.
*   searching for only customer classes
    if custNameRange <> '^'.
*     build up the customer name range used for select statements
      concatenate custNameRange '%' into altCustomerNameRange.

      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and clsname like custNameRange
               and langu = language
               and ( clsname like 'ZC%' or clsname like 'YC%' )
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and langu = language
                 and ( clsname like 'ZC%' or clsname like 'YC%' )
                 and ( author in rangeAuthor or changedby in rangeAuthor )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    else.
*     Searching using normal name ranges
      select clsname descript msg_id
             from vseoclass
             appending corresponding fields of table ilocClass
             where clsname in rangeClass
               and ( clsname like 'ZC%' or clsname like 'YC%' )
               and ( author in rangeAuthor or changedby in rangeAuthor )
               and version = '1'
               and ( state = '0' or state = '1' ).
      if sy-subrc <> 0.
        select clsname descript msg_id
               from vseoclass
               appending corresponding fields of table ilocClass
               where clsname in rangeClass
                 and ( clsname like 'ZC%' or clsname like 'YC%' )
                 and ( author in rangeAuthor or changedby in rangeAuthor )
                 and version = '0'
                 and ( state = '0' or state = '1' ).
      endif.
    endif.
  endif.
endform.                                                                          "findClassesByWildcard


*-------------------------------------------------------------------------------------------------------
*  checkClassDoesExist...
*-------------------------------------------------------------------------------------------------------
form checkClassDoesExist using iLocClass like iClasses[]
                               rangeClass like soClassName[].

data: waClass type tClass.

  select single clsname descript msg_id
         from vseoclass
         into corresponding fields of waClass
         where clsname in rangeClass
           and version = '1'
           and ( state = '0' or state = '1' ).

  if sy-subrc <> 0.
    select single clsname descript msg_id
         from vseoclass
         into corresponding fields of waClass
         where clsname in rangeClass
           and version = '0'
           and ( state = '0' or state = '1' ).
  endif.

   if not waClass-clsname is initial.
     append waClass to iLocClass.
   endif.
endform.                                                                            "checkClassDoesExist

*-------------------------------------------------------------------------------------------------------
*  scanForAdditionalClassStuff...
*-------------------------------------------------------------------------------------------------------
form scanForAdditionalClassStuff using iLocClasses like iClasses[]
                                       iLocFunctions like iFunctions[]
                                       value(getTextElements)
                                       value(getMessages)
                                       value(getCustDictStructures)
                                       value(getFunctions)
                                       value(getIncludes)
                                       value(customerOnly)
                                       value(customerNameRange)
                                       value(recursiveIncludeSearch)
                                       value(recursiveFuncSearch)
                                       value(recursiveClassSearch)
                                       value(soLocPackage) like soPack[].

data: waClass type tClass.
data: waMethod type tMethod.
data: myTabix type syTabix.
data: scanningForClasses type abap_bool value FALSE.
data: classNewLines type i value 0.
data: classCurrentLines type i value 0.

  loop at iLocClasses into waClass where scanned is initial.
*  Once we have a list of all the classes we need to loop round them an select all the other objects
    myTabix = sy-tabix.
    perform findClassDetails using waClass-clsName
                                   waClass
                                   iLocFunctions[]
                                   getTextElements
                                   getMessages
                                   getFunctions
                                   getCustDictStructures
                                   customerOnly
                                   customerNameRange.

*   Set the scanned class so we do not check them again when running recursively.
    waClass-scanned = 'X'.
    modify iLocClasses from waClass index myTabix.
  endloop.

* Now we have all the classes and details we need to find extra classes
  if not recursiveClassSearch is initial.
    classCurrentLines = lines( iLocClasses ).
    loop at iLocClasses into waClass.
*     Don't try and find any other details for an exception class
      if ( waClass-clsName ns 'ZCX_' or waClass-clsName ns 'CX_'  ).
*       Find any classes defined in the main class definition
        perform scanForClasses using waClass-privateClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[]
                                     soLocPackage[].

        perform scanForClasses using waClass-publicClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[]
                                     soLocPackage[].

        perform scanForClasses using waClass-protectedClassKey
                                     waClass-clsname
                                     customerOnly
                                     customerNameRange
                                     iLocClasses[]
                                     soLocPackage[].

        loop at waClass-iMethods into waMethod.
*         Find any classes defined in any of the methods
          perform scanForClasses using waMethod-methodKey
                                       waClass-clsname
                                       customerOnly
                                       customerNameRange
                                       iLocClasses[]
                                       soLocPackage[].
        endloop.
      endif.
    endloop.

*   We have a list of all the classes so lets go and find their details
    classNewLines = lines( iLocClasses ).
    if classNewLines > classCurrentLines.
      perform scanForAdditionalClassStuff using iLocClasses[]
                                                iLocFunctions[]
                                                getTextElements
                                                getMessages
                                                getCustDictStructures
                                                getFunctions
                                                getIncludes
                                                customerOnly
                                                customerNameRange
                                                recursiveIncludeSearch
                                                recursiveFuncSearch
                                                recursiveClassSearch
                                                soLocPackage[].
    endif.
  endif.
endform.                                                                   "scanForAdditionalClassStuff

*-------------------------------------------------------------------------------------------------------
*  findClassDetails...
*-------------------------------------------------------------------------------------------------------
form findClassDetails using value(className)
                                  waClass type tClass
                                  iLocFunctions like iFunctions[]
                                  value(getTextElements)
                                  value(getMessages)
                                  value(getFunctions)
                                  value(getCustDictStructures)
                                  value(customerOnly)
                                  value(customerNameRange).

data: iEmptySelectionTexts type standard table of tTextTable.
data: myTabix type syTabix.
data: waMethod type tMethod.
data: rnBlankAuthor like soAuthor[].
data: rnBlankPackage like soPack[].
data: waInterface type tInterface.

* Build up the keys we will use for finding data
  perform buildClassKeys using waClass.

  if waClass-descript is initial.
    perform findClassDescription using className
                                       waClass-descript.
  endif.

* Find the class attributes.
  select single exposure msg_id state clsfinal r3release
                from vseoclass
                into (waClass-exposure, waClass-msg_id, waClass-state,
                      waClass-clsfinal, waClass-r3release)
                where clsName = waClass-clsName.

* Don't try and find any other details for an exception class
  if ( waClass-clsName cs 'ZCX_' or waClass-clsName cs 'CX_'  ).
*   Exception texts
    perform findExceptionTexts using waClass-publicClassKey
                                     waClass-iConcepts[].
    waClass-scanned = 'X'.
  else.
    if not getTextElements is initial.
*     Find the class texts from out of the database.
      perform retrieveProgramTexts using iEmptySelectionTexts[]
                                         waClass-iTextElements[]
                                         waClass-textElementKey.
    endif.


